<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR.js GeoJSON Overlay</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.rawgit.com/jeromeetienne/AR.js/1.7.6/aframe/build/aframe-ar.min.js"></script>
    <script src="https://unpkg.com/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>

    <script>
        AFRAME.registerComponent('geojson', {
            schema: {
                src: { type: 'string' },
                color: { type: 'color', default: '#39FF14' },  // Using hex color code for neon-green
                opacity: { type: 'number', default: 0.5 }
            },
            init: function () {
                var self = this;
                console.log('GeoJSON component initialized.');
                console.log('Loading GeoJSON from:', this.data.src);

                // Debugging: Check if the event fires
                this.el.sceneEl.addEventListener('gps-camera-update-position', function () {
                    console.log('GPS camera is ready and event fired.');

                    self.loadGeoJSON();
                });

                // Fallback to load immediately if GPS data isn't necessary for initial testing
                self.loadGeoJSON();
            },
            loadGeoJSON: function() {
                var self = this;
                var loader = new THREE.FileLoader();
                loader.load(self.data.src, function (data) {
                    console.log('GeoJSON file loaded successfully from:', self.data.src);
                    var geoData = JSON.parse(data);
                    var material = new THREE.MeshBasicMaterial({
                        color: self.data.color,
                        transparent: true,
                        opacity: self.data.opacity,
                        side: THREE.DoubleSide,
                        wireframe: true
                    });

                    var totalPoints = 0;

                    geoData.features.forEach(function (feature, featureIndex) {
                        if (feature.geometry.type === 'Polygon') {
                            console.log('Processing Polygon feature:', featureIndex);
                            var shape = new THREE.Shape();
                            feature.geometry.coordinates[0].forEach(function (coord, index) {
                                totalPoints++;
                                var lat = coord[1];
                                var lon = coord[0];
                                var altitude = coord[2] || 0;
                                console.log(`Coordinate ${index}: lat=${lat}, lon=${lon}, altitude=${altitude}`);

                                var position = self.el.sceneEl.systems['gps-camera'].latLonToWorld(lat, lon);

                                if (position) {
                                    console.log('Converted to world position:', position);
                                    if (index === 0) {
                                        shape.moveTo(position.x, position.z);
                                    } else {
                                        shape.lineTo(position.x, position.z);
                                    }
                                } else {
                                    console.warn('Failed to convert lat/lon to world position for coordinate:', index);
                                }
                            });
                            var geometry = new THREE.ShapeBufferGeometry(shape);
                            var mesh = new THREE.Mesh(geometry, material);
                            self.el.setObject3D('mesh' + featureIndex, mesh);
                            console.log('Polygon feature rendered:', featureIndex);
                        } else {
                            console.warn('Unsupported geometry type:', feature.geometry.type);
                        }
                    });

                    console.log('Total number of points loaded from GeoJSON:', totalPoints);
                }, function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                }, function (err) {
                    console.error('An error happened while loading the GeoJSON file from:', self.data.src, err);
                });
            }
        });

        AFRAME.registerComponent('gps-camera', {
            init: function() {
                // Set initial fallback coordinates
                this.el.setAttribute('gps-camera', {
                    position: {
                        latitude: 48.53907734654573,
                        longitude: 8.076382418101675
                    }
                });
                console.log('Fallback coordinates set:', {
                    latitude: 48.53907734654573,
                    longitude: 8.076382418101675
                });
            }
        });

        AFRAME.registerComponent('rotation-reader', {
            init: function () {
                this.lastRotation = null;
            },
            tick: function () {
                var rotation = this.el.getAttribute('rotation');
                if (this.lastRotation === null || rotation.x !== this.lastRotation.x || rotation.y !== this.lastRotation.y || rotation.z !== this.lastRotation.z) {
                    console.log('Camera rotation:', rotation);
                    this.lastRotation = Object.assign({}, rotation);
                }
            }
        });
    </script>
</head>
<body style="margin: 0; overflow: hidden;">
    <a-scene embedded arjs="sourceType: webcam;">
        <!-- Camera setup -->
        <a-camera gps-camera rotation-reader></a-camera>

        <!-- GeoJSON Loader -->
        <a-entity id="geojson-entity"
                  geojson="src: https://mainkai.github.io/ar/assets/suitability_areas/kwp_oberkirch/Suitability%20area.geojson; color: #39FF14; opacity: 0.5;">
        </a-entity>
    </a-scene>
</body>
</html>
