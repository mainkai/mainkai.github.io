<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR.js GeoJSON Overlay</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.rawgit.com/jeromeetienne/AR.js/1.7.6/aframe/build/aframe-ar.min.js"></script>
    <script src="https://unpkg.com/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
    <a-scene embedded arjs="sourceType: webcam;">
        <!-- Camera setup -->
        <a-camera gps-camera rotation-reader></a-camera>

        <!-- GeoJSON Loader -->
        <a-entity id="geojson-entity"
                  geojson="src: ../assets/suitability_areas/kwp_oberkirch/Suitability area.geojson; color: neon-green; opacity: 0.5;">
        </a-entity>
    </a-scene>

    <script>
        AFRAME.registerComponent('geojson', {
            schema: {
                src: { type: 'string' },
                color: { type: 'color', default: 'neon-green' },
                opacity: { type: 'number', default: 0.5 }
            },
            init: function () {
                var self = this;
                console.log('GeoJSON component initialized.');
                console.log('Loading GeoJSON from:', this.data.src);

                var loader = new THREE.FileLoader();
                loader.load(this.data.src, function (data) {
                    console.log('GeoJSON file loaded successfully.');
                    var geoData = JSON.parse(data);
                    var material = new THREE.MeshBasicMaterial({
                        color: self.data.color,
                        transparent: true,
                        opacity: self.data.opacity,
                        side: THREE.DoubleSide,
                        wireframe: true
                    });

                    geoData.features.forEach(function (feature, featureIndex) {
                        if (feature.geometry.type === 'Polygon') {
                            console.log('Processing Polygon feature:', featureIndex);
                            var shape = new THREE.Shape();
                            feature.geometry.coordinates[0].forEach(function (coord, index) {
                                var lat = coord[1];
                                var lon = coord[0];
                                var altitude = coord[2] || 0;
                                console.log(`Coordinate ${index}: lat=${lat}, lon=${lon}, altitude=${altitude}`);

                                var position = self.el.sceneEl.systems['gps-camera'].latLonToWorld(lat, lon);

                                if (position) {
                                    console.log('Converted to world position:', position);
                                    if (index === 0) {
                                        shape.moveTo(position.x, position.z);
                                    } else {
                                        shape.lineTo(position.x, position.z);
                                    }
                                } else {
                                    console.warn('Failed to convert lat/lon to world position for coordinate:', index);
                                }
                            });
                            var geometry = new THREE.ShapeBufferGeometry(shape);
                            var mesh = new THREE.Mesh(geometry, material);
                            self.el.setObject3D('mesh' + featureIndex, mesh);
                            console.log('Polygon feature rendered:', featureIndex);
                        } else {
                            console.warn('Unsupported geometry type:', feature.geometry.type);
                        }
                    });
                }, function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                }, function (err) {
                    console.error('An error happened while loading the GeoJSON file:', err);
                });
            }
        });

        AFRAME.registerComponent('rotation-reader', {
            tick: function () {
                var rotation = this.el.getAttribute('rotation');
                console.log('Camera rotation:', rotation);
            }
        });
    </script>
</body>
</html>
